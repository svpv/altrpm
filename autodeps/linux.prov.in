#!/bin/sh -efu
#
# Copyright (C) 2000-2006  Dmitry V. Levin <ldv@altlinux.org>
# Copyright (C) 2007       Alexey Tourbin <at@altlinux.org>
#
# find-provides - generate list of linux-specific package provides.
# Inspired by tool with same name from RPM distribution.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

. @RPMCONFIGDIR@/functions
ValidateBuildRoot

workdir=
exit_handler()
{
	local rc=$?
	trap - EXIT
	[ -z "$workdir" ] || rm -rf "$workdir"
	cat >/dev/null
	exit $rc
}

trap exit_handler EXIT HUP INT QUIT PIPE TERM

methods=$(SetupMethods prov "$RPM_FINDPROV_METHOD")
if [ -z "$methods" ]; then
	Info "AutoProv disabled, nothing to do"
	exit 0
fi

workdir=$(mktemp -dt "$PROG".XXXXXXXX)

# filter file list through TOPDIR and SKIPLIST patterns
while IFS= read -r f; do
	fname="${f#$RPM_BUILD_ROOT}"
	if [ -n "${RPM_FINDPROV_TOPDIR-}" ] && [ -z "${fname%%$RPM_FINDPROV_TOPDIR/*}" ]; then
		Debug "skip $f due to RPM_FINDPROV_TOPDIR=$RPM_FINDPROV_TOPDIR"
		continue
	fi
	if [ -n "${RPM_FINDPROV_SKIPLIST-}" ]; then
		for skip in $RPM_FINDPROV_SKIPLIST; do
			if [ -z "${fname##$skip}" ]; then
				Debug "skip $f due to RPM_FINDPROV_SKIPLIST pattern $skip"
				continue 2
			fi
		done
	fi
	echo "$f"
done >"$workdir"/files

if ! [ -s "$workdir"/files ]; then
	Info "empty file list, nothing to do"
	exit 0
fi

# filter file list through file(1) to append types (dereference symlinks)
if ! file -L -NF$'\t' -f "$workdir"/files >"$workdir"/files+types; then
	sed -n '/\t *ERROR:/p' "$workdir"/files+types >&2
	sed -i '/\t *ERROR:/d' "$workdir"/files+types
fi

if ! [ -s "$workdir"/files+types ]; then
	Info "empty file list, nothing to do"
	exit 0
fi

found=
RunMethod()
{
	local exe="$1"; shift
	local filter="$exe".files
	if ! [ -x "$filter" ]; then
		# XXX should be Fatal
		Info "$filter not available"
		return
	fi
	local filelist="$workdir/${exe##*/}".files
	local deplist="$workdir/${exe##*/}".deps
	Debug "running $filter"
	"$filter" <"$workdir"/files+types >"$filelist"
	Verbose "$filter: $(wc -l <"$filelist") files"
	[ -s "$filelist" ] || return 0
	# XXX validate $filelist
	Debug "running $exe"
	"$exe" <"$filelist" >"$deplist"
	Verbose "$exe: $(wc -l <"$deplist") dependencies"
	[ -s "$deplist" ] || return 0
	found=1
}

Info "running scripts ($methods)"
RunMethods prov "$methods" RunMethod
[ -z "$found" ] || (set +f; LC_COLLATE=C sort -u "$workdir"/*.deps) || exit 1

exit 0

# Normalize buildroot.
real_buildroot="$(cd "$RPM_BUILD_ROOT" && /bin/pwd)" || exit 1

FIND_LIBS=
FIND_MONO=
FIND_PAM=
FIND_PERL=
FIND_PKGCONFIG=
FIND_PYTHON=
FIND_SHELL=
FIND_TCL=

ParseMethod()
{
	local t
	for	t in "$@"; do
		case "${t/%,}" in
			no|none|off|false)
				FIND_LIBS=
				FIND_MONO=
				FIND_PAM=
				FIND_PERL=
				FIND_PKGCONFIG=
				FIND_PYTHON=
				FIND_SHELL=
				FIND_TCL=
				;;
			java|nojava)
				;;
			lib)
				FIND_LIBS=1
				;;
			nolib)
				FIND_LIBS=
				;;
			mono)
				FIND_MONO=1
				;;
			nomono)
				FIND_MONO=
				;;
			pam)
				FIND_PAM=1
				;;
			nopam)
				FIND_PAM=
				;;
			perl)
				FIND_PERL=1
				;;
			noperl)
				FIND_PERL=
				;;
			pkgconfig)
				FIND_PKGCONFIG=1
				;;
			nopkgconfig)
				FIND_PKGCONFIG=
				;;
			python)
				FIND_PYTHON=1
				;;
			nopython)
				FIND_PYTHON=
				;;
			sh|shell)
				FIND_SHELL=1
				;;
			nosh|noshell)
				FIND_SHELL=
				;;
			tcl)
				FIND_TCL=1
				;;
			notcl)
				FIND_TCL=
				;;
			all)
				FIND_LIBS=1
				FIND_MONO=1
				FIND_PAM=1
				FIND_PERL=1
				FIND_PKGCONFIG=1
				FIND_PYTHON=1
				FIND_SHELL=1
				FIND_TCL=1
				;;
			default|yes|true)
				ParseMethod $RPM_FINDPROV_DEFAULT_METHOD || return 1
				;;
			*)
				Fatal "Unrecognized find-provides method: $t"
				;;
		esac
	done
}
ParseMethod $RPM_FINDPROV_METHOD

if [ -z "$FIND_LIBS" -a \
     -z "$FIND_MONO" -a \
     -z "$FIND_PAM" -a \
     -z "$FIND_PERL" -a \
     -z "$FIND_PKGCONFIG" -a \
     -z "$FIND_PYTHON" -a \
     -z "$FIND_SHELL" -a \
     -z "$FIND_TCL" ]; then
	# Nothing to do
	cat >/dev/null 2>&1
	exit 0
fi

ulimit -c 0

case "$LD_PRELOAD" in
	*libfakeroot*)
		unset LD_PRELOAD
		;;
	*libbuildreq.so*)
		unset LD_PRELOAD
		;;
esac

FOUND_PROVS=
LIST_MONO=
LIST_PERL=
LIST_PYTHON=
LIST_TCL=

ListScriptProvs()
{
	local f t
	f="$1"
	t="$2"

	if [ -z "${t##ASCII *text*}" ]; then
		if [ -z "${f%%$RPM_BUILD_ROOT/etc/pam.d/*}" ]; then
			if [ -n "$FIND_PAM" ]; then
				local r
				r="$(@RPMCONFIGDIR@/pam.prov "$f")" || return 1
				[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
			fi
			return 0
		fi

		# Ignore symlinks for non-PAM scripts.
		[ ! -L "$f" ] || return 0

		if [ "${f##*/}" = ".provides.sh" ]; then
			if [ -n "$FIND_SHELL" ]; then
				local r
				r="$(@RPMCONFIGDIR@/shell.prov "$f")" || return 1
				[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
			fi
			return 0
		fi
	fi

	# Ignore symlinks for non-PAM scripts.
	[ ! -L "$f" ] || return 0

	if [ -z "${t##perl script text*}" -o -z "${t##Perl5 module source text}" -o -z "${f%%*.p[lmh]}" ]; then
		if [ -n "$FIND_PERL" ]; then
			[ -z "$LIST_PERL" ] && LIST_PERL="$f" || LIST_PERL="$LIST_PERL
$f"
		fi
	fi

	if [ -z "${f%%*.py}" -o -z "${f%%*.pyo}" -o -z "${f%%*.pyc}" -o -z "${f%%*.pth}" ]; then
		if [ -n "$FIND_PYTHON" ]; then
			[ -z "$LIST_PYTHON" ] && LIST_PYTHON="$f" || LIST_PYTHON="$LIST_PYTHON
$f"
		fi
	fi

	if [ "${f##*/}" = "pkgIndex.tcl" ]; then
		if [ -n "$FIND_TCL" ]; then
			[ -z "$LIST_TCL" ] && LIST_TCL="$f" || LIST_TCL="$LIST_TCL
$f"
		fi
	fi
}

FindMonoProvs()
{
	[ -n "$FIND_MONO" -a -n "$LIST_MONO" -a -x "@RPMCONFIGDIR@/mono.prov" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_MONO" |
	     @RPMCONFIGDIR@/mono.prov "$RPM_BUILD_DIR" "$RPM_BUILD_ROOT" "$RPM_LIBDIR")" ||
		return 1
	[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
}

FindPerlProvs()
{
	[ -n "$FIND_PERL" -a -n "$LIST_PERL" ] || return 0
	local r
	r="$(printf %s\\n "$LIST_PERL" |@RPMCONFIGDIR@/perl.prov)" || return 1
	[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
}

FindPythonProvs()
{
	[ -n "$FIND_PYTHON" -a -n "$LIST_PYTHON" ] || return 0
	[ -x "$RPM_PYTHON" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_PYTHON" |"$RPM_PYTHON" @RPMCONFIGDIR@/python.prov.py)" || return 1
	[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
}

FindTclProvs()
{
	[ -n "$FIND_TCL" -a -n "$LIST_TCL" ] || return 0
	[ -x "$RPM_TCLSH" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_TCL" |@RPMCONFIGDIR@/tcl.prov)" || return 1
	[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
}


dump_ld_config='@RPMCONFIGDIR@/dump_ld_config'
DEF_RPM_FINDPROV_LIB_PATH="$("$dump_ld_config" '' "$RPM_BUILD_ROOT" |tr -s '\n' :)"
DEF_RPM_FINDPROV_LIB_PATH="$DEF_RPM_FINDPROV_LIB_PATH:/$RPM_LIB:$RPM_LIBDIR:$("$dump_ld_config" |tr -s '\n' :)"
DEF_RPM_FINDPROV_LIB_PATH="$(printf %s "$DEF_RPM_FINDPROV_LIB_PATH" |sed -e 's/^:\+//; s/:\+$//')"
RPM_FINDPROV_LIB_PATH="$RPM_FINDPROV_LIB_PATH:$DEF_RPM_FINDPROV_LIB_PATH"
RPM_FINDPROV_LIB_PATH="$(printf %s "$RPM_FINDPROV_LIB_PATH" |sed -e 's/^:\+//; s/:\+$//')"

lookup_path()
{
	local d dir path found=
	dir="$1" && shift
	path="$1" && shift
	for d in $(printf %s "$path" |tr : ' '); do
		[ "$d" = "$dir" ] || continue
		found="$d"
		break
	done
	[ -n "$found" ] && return 0 || return 1
}

# Note this works for both a.out and ELF executables.
FindLibProvs()
{
	[ -n "$FIND_LIBS" ] || return 0

	local braces dir dump f name suffix
	f="$1"
	dir="${fname%/*}"
	[ -n "$dir" ] || return 0
	name="${fname##*/}"
	[ -n "$name" ] || return 0

	[ "$dir" = "/$RPM_LIB/security" ] || lookup_path "$dir" "$RPM_FINDPROV_LIB_PATH" || return 0

	if dump="$(objdump -p "$f")"; then
		if [ "$dir" = "/$RPM_LIB/security" ]; then
			printf 'PAM(%s)\n' "$name"
			return 0
		fi
		local soname
		soname="$(printf %s\\n "$dump" |sed -ne 's/^[[:space:]]*SONAME[[:space:]]\+\([^[:space:]]\+\)[[:space:]]*$/\1/p')" || return 1
		suffix="$(printf %s\\n "$dump" |sed -ne 's/^.*file format \(elf64\).*$/(64bit)/p')" || return 1
		[ -z "$suffix" ] && braces= || braces='()'
		while :; do
			# For libraries with soname, ignore all but files named as soname.
			[ -z "$soname" -o "$soname" = "$name" ] || break

			# Treat symlinks specially.
			if [ -L "$f" ]; then
				[ -n "$soname" ] || break
				local real realpath realdir
				realpath=$(readlink -fv "$f") || break
				real="${realpath#$real_buildroot}"
				# Ignore symlinks leading out of buildroot.
				[ "$real" != "$realpath" ] || break
				realdir="${real%/*}"
				# Ignore symlinks to shorter locations.
				[ "${#dir}" -le "${#realdir}" ] || break
			fi

			# soname is either empty or equal to name
			soname="$name"

			# Check for non-default path.
			local nondefdir=
			lookup_path "$dir" "$DEF_RPM_FINDPROV_LIB_PATH" || nondefdir="$dir"

			# Output soname.
			if [ -z "$nondefdir" ]; then
				printf '%s\n' "$soname$braces$suffix"
			else
				printf '%s/%s\n' "$nondefdir" "$soname$braces$suffix"
			fi

			# Output version definitions.
    			printf %s\\n "$dump" | awk "-vsoname=$soname" "-vnondefdir=$nondefdir" "-vsuffix=$suffix" '
				BEGIN {start=0;}
				/^Version definitions:$/ {start=1;}
				/^[0-9]/ && (start==1) && ($4!="") && ($4!=soname) {
					if (nondefdir=="")
						printf("%s(%s)%s\n",soname,$4,suffix)
					else
						printf("%s/%s(%s)%s\n",nondefdir,soname,$4,suffix)
				}
				/^$/ {start=0;}
			' || return 1

			break
		done
	fi
}

while IFS= read -r f; do
	if t="$(file -bL "$f")"; then
		if [ -z "${fname##/usr/share/pkgconfig/*.pc}" -o -z "${fname##$RPM_LIBDIR/pkgconfig/*.pc}" ]; then
			[ -n "$FIND_PKGCONFIG" ] || continue
			r="$(@RPMCONFIGDIR@/pkgconfig.prov "$f")"
			[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
		elif [ -z "${t##* text*}" ]; then
			ListScriptProvs "$f" "$t"
		elif [ -z "${t##*ELF* shared object*}" ]; then
			r="$(FindLibProvs "$f")"
			[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
			[ -z "$LIST_PYTHON" ] && LIST_PYTHON="$f" || LIST_PYTHON="$LIST_PYTHON
$f"
		elif [ -z "${t##*MS Windows PE*}" ]; then
			[ -z "$LIST_MONO" ] && LIST_MONO="$f" || LIST_MONO="$LIST_MONO
$f"
		elif [ "${f##*/}" = '__init__.py' ]; then
			# Zero-length python init files have major sense.
			[ -z "$LIST_PYTHON" ] && LIST_PYTHON="$f" || LIST_PYTHON="$LIST_PYTHON
$f"
		fi
	else
		Info "$f: file type not available"
	fi
done

# Find provides in listed .Net executables and shared libraries, if any
FindMonoProvs

# Find provides in listed perl scripts, if any
FindPerlProvs

# Find provides in listed python scripts and shared libraries, if any
FindPythonProvs

# Find provides in listed tcl index files, if any
FindTclProvs
