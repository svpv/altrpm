#!/bin/sh -efu
#
# Copyright (C) 2000-2006  Dmitry V. Levin <ldv@altlinux.org>
# Copyright (C) 2007       Alexey Tourbin <at@altlinux.org>
#
# find-requires - generate list of linux-specific package requires.
# Inspired by tool with same name from RPM distribution.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

. @RPMCONFIGDIR@/functions
ValidateBuildRoot

workdir=
exit_handler()
{
	local rc=$?
	trap - EXIT
	[ -z "$workdir" ] || rm -rf "$workdir"
	cat >/dev/null
	exit $rc
}

trap exit_handler EXIT HUP INT QUIT PIPE TERM

methods=$(SetupMethods req "$RPM_FINDREQ_METHOD")
if [ -z "$methods" ]; then
	Info "AutoReq disabled, nothing to do"
	exit 0
fi

workdir=$(mktemp -dt "$PROG".XXXXXXXX)

# filter file list through TOPDIR and SKIPLIST patterns
while IFS= read -r f; do
	fname="${f#$RPM_BUILD_ROOT}"
	if [ -n "${RPM_FINDREQ_TOPDIR-}" ] && [ -z "${fname%%$RPM_FINDREQ_TOPDIR/*}" ]; then
		Debug "skip $f due to RPM_FINDREQ_TOPDIR=$RPM_FINDREQ_TOPDIR"
		continue
	fi
	if [ -n "${RPM_FINDREQ_SKIPLIST-}" ]; then
		for skip in $RPM_FINDREQ_SKIPLIST; do
			if [ -z "${fname##$skip}" ]; then
				Debug "skip $f due to RPM_FINDREQ_SKIPLIST pattern $skip"
				continue 2
			fi
		done
	fi
	echo "$f"
done >"$workdir"/files

if ! [ -s "$workdir"/files ]; then
	Info "empty file list, nothing to do"
	exit 0
fi

# filter file list through file(1) to append types
if ! file -NF$'\t' -f "$workdir"/files >"$workdir"/files+types; then
	sed -n '/\t *ERROR:/p' "$workdir"/files+types >&2
	exit 1
fi

found=
RunMethod()
{
	local exe="$1"; shift
	local filter="$exe".files
	if ! [ -x "$filter" ]; then
		# XXX should be Fatal
		Info "$filter not available"
		return
	fi
	local filelist="$workdir/${exe##*/}".files
	local deplist="$workdir/${exe##*/}".deps
	Debug "running $filter"
	"$filter" <"$workdir"/files+types >"$filelist"
	Verbose "$filter: $(wc -l <"$filelist") files"
	[ -s "$filelist" ] || return 0
	# XXX validate $filelist
	Debug "running $exe"
	"$exe" <"$filelist" >"$deplist"
	Verbose "$exe: $(wc -l <"$deplist") dependencies"
	[ -s "$deplist" ] || return 0
	found=1
}

Info "running scripts ($methods)"
RunMethods req "$methods" RunMethod
[ -z "$found" ] || (set +f; LC_COLLATE=C sort -u "$workdir"/*.deps) || exit 1

exit 0

FIND_FILES=
FIND_JAVA=
FIND_LIBPERL=
FIND_LIBS=
FIND_MONO=
FIND_PAM=
FIND_PERL=
FIND_PKGCONFIG=
FIND_PYTHON=
FIND_TCL=
libperl_so=

ParseMethod()
{
	local t
	for t in "$@"; do
		case "${t/%,}" in
			no|none|off|false)
				FIND_FILES=
				FIND_JAVA=
				FIND_LIBPERL=
				FIND_LIBS=
				FIND_MONO=
				FIND_PAM=
				FIND_PERL=
				FIND_PKGCONFIG=
				FIND_PYTHON=
				FIND_TCL=
				;;
			java)
				FIND_JAVA=1
				;;
			nojava)
				FIND_JAVA=
				;;
			lib|library)
				FIND_LIBS=1
				;;
			libperl)
				FIND_LIBPERL=1
				;;
			nolib|nolibrary)
				FIND_LIBS=
				;;
			nolibperl)
				FIND_LIBPERL=
				;;
			files)
				FIND_FILES=1
				;;
			nofiles)
				FIND_FILES=
				;;
			mono)
				FIND_MONO=1
				;;
			nomono)
				FIND_MONO=
				;;
			pam)
				FIND_PAM=1
				;;
			nopam)
				FIND_PAM=
				;;
			perl)
				FIND_PERL=1
				FIND_LIBPERL=1
				;;
			noperl)
				FIND_PERL=
				FIND_LIBPERL=
				;;
			pkgconfig)
				FIND_PKGCONFIG=1
				;;
			nopkgconfig)
				FIND_PKGCONFIG=
				;;
			python)
				FIND_PYTHON=1
				;;
			nopython)
				FIND_PYTHON=
				;;
			tcl)
				FIND_TCL=1
				;;
			notcl)
				FIND_TCL=
				;;
			all)
				FIND_FILES=1
				FIND_LIBPERL=1
				FIND_LIBS=1
				FIND_MONO=1
				FIND_JAVA=1
				FIND_PAM=1
				FIND_PERL=1
				FIND_PKGCONFIG=1
				FIND_PYTHON=1
				FIND_TCL=1
				;;
			default|yes|true)
				ParseMethod $RPM_FINDREQ_DEFAULT_METHOD
				;;
			*)
				Fatal "Unrecognized find-requires method: $t"
				;;
		esac
	done
}
ParseMethod $RPM_FINDREQ_METHOD

FIND_SCRIPT=
if [ -n "$FIND_PAM" -o \
     -n "$FIND_PERL" -o \
     -n "$FIND_PYTHON" -o \
     -n "$FIND_TCL" ]; then
	FIND_SCRIPT=1
fi

if [ -z "$FIND_FILES" -a \
     -z "$FIND_JAVA" -a \
     -z "$FIND_LIBPERL" -a \
     -z "$FIND_LIBS" -a \
     -z "$FIND_MONO" -a \
     -z "$FIND_PKGCONFIG" -a \
     -z "$FIND_SCRIPT" ]; then
	# Nothing to do
	exit
fi

if [ -n "$*" ]; then
	# We do not handle arguments yet...
	exit
fi

. @RPMCONFIGDIR@/find-package

ulimit -c 0

case "$LD_PRELOAD" in
	*libfakeroot*)
		unset LD_PRELOAD
		;;
	*libbuildreq.so*)
		unset LD_PRELOAD
		;;
esac

FOUND_REQS=
LIST_JAVA=
LIST_MONO=
LIST_PERL=
LIST_PYTHON=
LIST_TCL=

FindJavaReqs()
{
	[ -n "$FIND_JAVA" -a -n "$LIST_JAVA" -a -x "@RPMCONFIGDIR@/java.req" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_JAVA" |
	     @RPMCONFIGDIR@/java.req "$RPM_BUILD_DIR" "$RPM_BUILD_ROOT" "$RPM_LIBDIR")" || return 1
	[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
}

FindMonoReqs()
{
	[ -n "$FIND_MONO" -a -n "$LIST_MONO" -a -x "@RPMCONFIGDIR@/mono.req" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_MONO" |
	     @RPMCONFIGDIR@/mono.req "$RPM_BUILD_DIR" "$RPM_BUILD_ROOT" "$RPM_LIBDIR")" || return 1
	[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
}

ListScriptReqs()
{
	[ -n "$FIND_SCRIPT" ] || return 0

	local f t
	f="$1"
	t="$2"
	if [ -z "${t##ASCII *text*}" -a -z "${f%%$RPM_BUILD_ROOT/etc/pam.d/*}" ]; then
		if [ -n "$FIND_PAM" ]; then
			local r
			r="$(@RPMCONFIGDIR@/pam.req "$f")" || return 1
			[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
		fi
	elif [ -z "${t##*perl script text*}" -o -z "${f%%*.p[lmh]}" ]; then
		if [ -n "$FIND_PERL" ]; then
			[ -z "$LIST_PERL" ] && LIST_PERL="$f" || LIST_PERL="$LIST_PERL
$f"
		fi
	elif [ -z "${f%%*.py}" ]; then
		if [ -n "$FIND_PYTHON" ]; then
			[ -z "$LIST_PYTHON" ] && LIST_PYTHON="$f" || LIST_PYTHON="$LIST_PYTHON
$f"
		fi
	elif [ -z "${f%%*.tcl}" ]; then
		if [ -n "$FIND_TCL" ]; then
			[ -z "$LIST_TCL" ] && LIST_TCL="$f" || LIST_TCL="$LIST_TCL
$f"
		fi
	fi
}

FindPerlReqs()
{
	[ -n "$LIST_PERL" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_PERL" |@RPMCONFIGDIR@/perl.req)" || return 1
	[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
}

FindPythonReqs()
{
	[ -n "$LIST_PYTHON" ] || return 0
	[ -x "$RPM_PYTHON" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_PYTHON" |"$RPM_PYTHON" @RPMCONFIGDIR@/python.req.py)" || return 1
	[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
}

FindTclReqs()
{
	[ -n "$LIST_TCL" ] || return 0
	[ -x "$RPM_TCLSH" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_TCL" |@RPMCONFIGDIR@/tcl.req)" || return 1
	[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
}

dump_ld_config='@RPMCONFIGDIR@/dump_ld_config'
shlib_req='@RPMCONFIGDIR@/shlib.req.awk'
elf_ldd='@RPMCONFIGDIR@/ldd'
RPM_FINDREQ_RPATH="$("$dump_ld_config" '' "$RPM_BUILD_ROOT")"
RPM_FINDREQ_RPATH="$RPM_FINDREQ_RPATH /$RPM_LIB $RPM_LIBDIR $("$dump_ld_config")"

FindLibReqs()
{
	[ -n "$FIND_LIBS" ] || return 0

	local braces canon_prefix deps dir dump f interp name pathname prefix rpath segments suffix v vers
	f="$1"

	if dump="$(objdump -p "$f")" &&
	   segments="$(readelf -l "$f")"; then
		interp="$(printf '%s\n' "$segments" |
			  sed -ne 's,^[[:space:]]*\[Requesting program interpreter: \(/[^]]\+\)\]$,\1,p')"
#		not yet, waiting for updated glibc...
#		[ -z "$interp" ] ||
#			printf '%s\n' "$interp"
		if printf '%s\n' "$segments" |
			egrep -qs '[[:space:]]\.gnu\.hash([[:space:]]|$)' &&
		   ! printf '%s\n' "$segments" |
			egrep -qs '[[:space:]]\.hash([[:space:]]|$)'; then
			echo 'rtld(GNU_HASH)'
		fi

		suffix="$(printf '%s\n' "$dump" |sed -ne 's/^.*file format \(elf64\).*$/(64bit)/p')"
		[ -z "$suffix" ] && braces= || braces='()'

		rpath="$(printf %s "$dump" |
			 awk '{if ($1=="RPATH") print $2}' |
			 tr -s : ' ' |
			 sed -e "s|\$ORIGIN|${fname%/*}|g")"
		if [ -n "$rpath" ]; then
			rpath="$rpath $RPM_FINDREQ_RPATH"
		else
			rpath="$RPM_FINDREQ_RPATH"
		fi
		rpath="$(printf %s "$rpath" |
			tr -s '[:space:]' '\n' |
			grep -v '^$' |
			LANG=C uniq |
			sed -e "s|^|$RPM_BUILD_ROOT&|" |
			tr -s '[:space:]' : |
			sed -e 's/^:\+//; s/:\+$//')"
		deps="$("$elf_ldd" -- "$f" "$rpath")" || return 1
		deps="$(printf %s "$deps" |sed -e "s|$RPM_BUILD_ROOT||g")"
		# Shared library dependencies, version references.
		for vers in `printf '%s\n' "$dump" |"$shlib_req"`; do
			name="$(printf %s "$vers" |cut -d: -f1)"
			vers="$(printf %s "$vers" |cut -d: -f2-)"
			pathname="$(printf %s "$deps" |awk "-vname=$name" '
NF>2 && $1==name && $2=="=>" && $3~/^/ {print $3}
NF==2 && $2~/^\(.+\)$/ {lib=$1; sub("^/.*/","",lib); if (lib==name) print $1}
				')"
			prefix="${pathname%/*}"
			canon_prefix="$(printf %s "$prefix/" |
				sed -e 's|/tls/|/|' -e 's|/sse2/|/|' -e "s|/$RPM_ARCH/|/|" -e 's|/i[3-9]86/|/|' -e 's|/\+$||')"
			if [ -z "$canon_prefix" -o -n "${canon_prefix##/*}" ]; then
				Info "WARNING: $fname: library $name not found"
				continue
			fi
			for dir in $RPM_FINDREQ_RPATH; do
				if [ "$canon_prefix" = "$dir" ]; then
					prefix=
					break
				fi
			done
			[ -z "$prefix" ] || prefix="$prefix/"
			v=
			for v in `printf %s "$vers" |tr : ' '`; do
				printf '%s%s(%s)%s\n' "$prefix" "$name" "$v" "$suffix"
			done
			[ -n "$v" ] ||
				printf '%s%s%s%s\n' "$prefix" "$name" "$braces" "$suffix"
		done

		if [ -n "$FIND_LIBPERL" -a -z "$libperl_so" -a -z "${f##*/usr/lib/perl?/*/auto/*.so}" ]; then
			libperl_so=`perl -MConfig -e 'print "$Config{libperl}\n"'`
			printf %s\\n "$libperl_so$braces$suffix"
		fi
	fi
}

FindExeReqs()
{
	if [ -x "$1" ]; then
		FindLibReqs "$1"
	fi
}

if [ -n "$RPM_SUBPACKAGE_NAME" ]; then
	if [ -n "${RPM_SUBPACKAGE_NAME%%glibc*}" -a -z "${RPM_SUBPACKAGE_NAME##*-devel-static}" ]; then
		FOUND_REQS=glibc-devel-static
	fi
fi

while IFS= read -r f; do
	if [ -n "$FIND_FILES" ]; then
		for p in $(grep '^[^#]' @RPMCONFIGDIR@/files.req.list); do
			if [ -z "${fname%%$p/*}" ]; then
				[ -z "$FOUND_REQS" ] && FOUND_REQS="$p" || FOUND_REQS="$FOUND_REQS
$p"
				break
			fi
		done
	fi
	if [ -z "${fname##/usr/share/pkgconfig/*.pc}" -o -z "${fname##$RPM_LIBDIR/pkgconfig/*.pc}" ]; then
		[ -n "$FIND_PKGCONFIG" ] || continue
		r="$(@RPMCONFIGDIR@/pkgconfig.req "$f")"
		[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
	elif [ -z "${t##*ELF* executable*dynamically linked*}" ]; then
		r="$(FindExeReqs "$f")"
		[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
	elif [ -z "${t##*ELF* shared object*}" ]; then
		r="$(FindLibReqs "$f")"
		[ -z "$FOUND_REQS" ] && FOUND_REQS="$r" || FOUND_REQS="$FOUND_REQS
$r"
		[ -z "$LIST_PYTHON" ] && LIST_PYTHON="$f" || LIST_PYTHON="$LIST_PYTHON
$f"
	elif [ -z "${t##*MS Windows PE*}" ]; then
		[ -z "$LIST_MONO" ] && LIST_MONO="$f" || LIST_MONO="$LIST_MONO
$f"
	elif [ -z "${t##*Zip archive data*}" -a -z "${f##*.jar}" ] ||
	     [ -z "${t##*compiled Java class data*}" ]; then
		[ -z "$LIST_JAVA" ] && LIST_JAVA="$f" || LIST_JAVA="$LIST_JAVA
$f"
	fi
done

# Find requires in listed Java files, if any
FindJavaReqs

# Find requires in listed .Net files, if any
FindMonoReqs

# Find requires in listed perl scripts, if any
FindPerlReqs

# Find requires in listed python scripts, if any
FindPythonReqs

# Find requires in listed tcl scripts, if any
FindTclReqs
