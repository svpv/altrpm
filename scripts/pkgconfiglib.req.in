#!/bin/sh -efu
#
# Copyright (C) 2007  Alexey Tourbin <at@altlinux.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

. @RPMCONFIGDIR@/functions

[ -n "${RPM_LIBDIR-}" ] || RPM_LIBDIR=`rpm --eval %_libdir`
PKG_CONFIG_PATH=$RPM_LIBDIR/pkgconfig:/usr/share/pkgconfig
[ -z "${RPM_BUILD_ROOT-}" ] ||
PKG_CONFIG_PATH=$RPM_BUILD_ROOT$RPM_LIBDIR/pkgconfig:$RPM_BUILD_ROOT/usr/share/pkgconfig:$PKG_CONFIG_PATH
export PKG_CONFIG_PATH

gcc= gcc_libdirs=
PkgconfigLibReq()
{
	local f="$1"; shift

	local srpm="${RPM_PACKAGE_NAME-}"
	[ -n "$srpm" ] || srpm=$(rpmquery --qf='%{SOURCERPM}' -f "$f" 2>/dev/null) || srpm=foo
	case "$srpm" in
		# Below we use "gcc -print-search-dirs" to determine library
		# search path.  If we build gcc itself, then e.g. libgcj.pc
		# (with -lgcj inside) cannot be processed reliably.
		gcc | gcc-* | gcc[1-9]* | *-gcc | *-gcc-* | *-gcc[1-9]* )
			Verbose "$f: $PROG disabled for gcc"
			return 0 ;;
	esac

	local pcLibs
	pcLibs=$(pkg-config --print-errors --libs "$f") || Fatal "failed to process $f"
	[ -n "$pcLibs" ] || return 0

	if [ -z "$gcc" ]; then
		gcc=/usr/bin/${RPM_ARCH:-noarch}-alt-linux-gcc
		[ -x "$gcc" ] || gcc=/usr/bin/gcc
		[ -z "${GCC_VERSION-}" ] || gcc=$gcc-$GCC_VERSION
		Verbose "gcc=$gcc"
		gcc_libdirs=$("$gcc" -print-search-dirs |sed -n 's/^libraries: =//p')
		[ -n "$gcc_libdirs" ] || Fatal "$gcc -print-search-dirs failed"
		gcc_libdirs=$(IFS="$IFS:"
			for dir in $gcc_libdirs; do
				[ -d "$dir" ] || continue
				CanonPath "$dir"
			done)
		gcc_libdirs=$(printf '%s\n' "$gcc_libdirs" |cat -n |sort -u -k2 |sort -n |cut -f2-)
		Verbose "gcc_libdirs=$(echo $gcc_libdirs)"
	fi

	GetLibs()
	{
		for arg in $pcLibs; do
			case "$arg" in
				-l?*) printf '%s\n' "${arg#-l}" ;;
			esac
		done
	}
	GetLibdirs()
	{
		for arg in $pcLibs; do
			case "$arg" in
				-L/?*) printf '%s\n' "${arg#-L}" ;;
				*-rpath[=,]/?*) printf '%s\n' "${arg#*-rpath[=,]}" ;;
			esac
		done
	}

	local libs libdirs
	libs=$(GetLibs)
	[ -n "$libs" ] || return 0
	libdirs=$(GetLibdirs)
	[ -z "$libdirs" ] || Verbose "$f: libdirs=$(echo $libdirs)"

	local lib libdir
	for lib in $libs; do
		lib=lib$lib.so
		if [ -n "${RPM_BUILD_ROOT-}" ]; then
			for libdir in $libdirs $gcc_libdirs; do
				[ -f "$RPM_BUILD_ROOT$libdir/$lib" ] ||
				# ... allow absolute symbolic links:
				[ -L "$RPM_BUILD_ROOT$libdir/$lib" ] || continue
				# The library is under RPM_BUILD_ROOT.
				# Nothing is required.  Do next lib.
				Verbose "$f: $lib -> \$RPM_BUILD_ROOT$libdir/$lib (skip)"
				continue 2
			done
		fi
		for libdir in $libdirs $gcc_libdirs; do
			[ -f "$libdir/$lib" ] || continue
			# The library is found in the host system.
			# Generate rpm dependency and do next lib.
			libdir=$(CanonPath "$libdir")
			local pkg n
			pkg=$(rpmquery --whatprovides --queryformat='%{NAME}\n' "$libdir/$lib" |sort -u)
			n=$(set -- $pkg; echo $#)
			if [ "$pkg" = glibc-devel ]; then
				Verbose "$f: $lib -> $pkg (skip)"
			elif [ $n -eq 1 ]; then
				Verbose "$f: $lib -> $pkg"
				printf '%s\n' "$pkg"
			elif [ $n -gt 1 ]; then
				Info "$f: $libdir/$lib provided by:$(echo '' $pkg)"
				Info "$f: $lib -> $libdir/$lib (raw, ambiguous)"
				printf '%s\n' "$libdir/$lib"
			else
				Info "$f: cannot map $libdir/$lib to rpm dependency (skip)"
			fi
			continue 2
		done
		Info "$f: cannot find $lib library path (skip)"
	done
}

ArgvFileAction PkgconfigLibReq "$@"
